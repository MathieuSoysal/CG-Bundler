use clap:: {Parser, Subcommand}; use std:: path:: PathBuf; use crate :: config:: CompressionConfig; use crate :: error:: Result; use crate :: rust_singler:: RustSingler; use crate :: discovery:: RecursiveFileDiscovery; use crate :: parser:: SynCodeParser; use crate :: minifier:: WhitespaceMinifier; use crate :: file_processor:: StandardFileProcessor; use crate :: reporter:: ConsoleErrorReporter; use crate :: performance:: MetricsCollector; #[derive(Parser, Debug)]#[command(name = "rust-singler")]#[command(version = "0.1.0")]#[command(about = "A Rust code compression tool that minifies Rust codebases into single-line format")]#[command(long_about = None)]pub struct CliArgs{#[command(subcommand)]pub command: Commands, #[arg(short, long, global = true)]pub verbose: bool, #[arg(long, global = true)]pub no_color: bool, #[arg(long, global = true)]pub no_metrics: bool,}#[derive(Subcommand, Debug)]pub enum Commands{Directory{#[arg(short, long)]input: PathBuf, #[arg(short, long)]output: PathBuf, #[arg(long, default_value_t = true)]preserve_strings: bool, #[arg(long)]keep_docs: bool, #[arg(long)]keep_tests: bool, #[arg(long)]multiline: bool,}, File{#[arg(short, long)]input: PathBuf, #[arg(short, long)]output: PathBuf, #[arg(long, default_value_t = true)]preserve_strings: bool, #[arg(long)]keep_docs: bool, #[arg(long)]keep_tests: bool, #[arg(long)]multiline: bool,},}pub struct CliApplication; impl CliApplication{pub fn new() -> Self{Self}#}impl Default for CliApplication{fn default() -> Self{Self:: new()}} #[derive(Debug, Clone)]pub struct CompressionConfig{pub preserve_string_formatting: bool, pub remove_doc_comments: bool, pub remove_test_code: bool, pub output_single_line: bool,}impl CompressionConfig{pub fn new() -> Self{Self:: default()}}impl Default for CompressionConfig{fn default() -> Self{Self{preserve_string_formatting: true, remove_doc_comments: true, remove_test_code: true, output_single_line: true,}}} use std:: path:: {Path, PathBuf}; use walkdir:: {DirEntry, WalkDir}; use crate :: error:: {ProcessingError, Result}; use crate :: traits:: FileDiscovery; pub struct RecursiveFileDiscovery; impl RecursiveFileDiscovery{pub fn new() -> Self{Self}#}impl FileDiscovery for RecursiveFileDiscovery{fn find_rust_files(& self, path:& Path) -> Result < Vec < PathBuf >> {if!path.exists(){return Err(ProcessingError:: FileNotFound(path.to_path_buf()));}let mut rust_files = Vec:: new(); if path.is_file(){if self.is_rust_file(path){rust_files.push(path.to_path_buf());}return Ok(rust_files);}for entry in WalkDir:: new(path).into_iter().filter_entry(| e | {if e.path() == path{return true;}if e.path().is_dir(){return!self.should_skip_directory(e.path());}true}){let entry = entry.map_err(| e | ProcessingError:: IoError(e.into()))?; let entry_path = entry.path(); if entry_path.is_file() && self.is_rust_file(entry_path){rust_files.push(entry_path.to_path_buf());}}rust_files.sort(); Ok(rust_files)}}impl Default for RecursiveFileDiscovery{fn default() -> Self{Self:: new()}} use std:: path:: PathBuf; use thiserror:: Error; #[derive(Error, Debug)]pub enum ProcessingError{#[error("File not found: {0}")]FileNotFound(PathBuf), #[error("Parse error: {0}")]ParseError(String), #[error("IO error: {0}")]IoError(#[from]std:: io:: Error), #[error("Compression error: {0}")]CompressionError(String), #[error("Invalid input path: {0}")]InvalidPath(PathBuf), #[error("Output directory creation failed: {0}")]OutputDirectoryError(String),}pub type Result < T >= std:: result:: Result < T, ProcessingError >; use std:: fs; use std:: path:: Path; use crate :: error:: {ProcessingError, Result}; use crate :: traits:: FileProcessor; pub struct StandardFileProcessor; impl StandardFileProcessor{pub fn new() -> Self{Self}#}impl FileProcessor for StandardFileProcessor{fn read_file(& self, path:& Path) -> Result < String > {if!path.exists(){return Err(ProcessingError:: FileNotFound(path.to_path_buf()));}fs:: read_to_string(path).map_err(| e | ProcessingError:: IoError(e))}fn write_file(& self, path:& Path, content:& str) -> Result < () > {self.ensure_output_directory(path)?; fs:: write(path, content).map_err(| e | ProcessingError:: IoError(e))}}impl Default for StandardFileProcessor{fn default() -> Self{Self:: new()}} pub mod cli; pub mod config; pub mod discovery; pub mod error; pub mod file_processor; pub mod minifier; pub mod parser; pub mod performance; pub mod reporter; pub mod rust_singler; pub mod syntax_tree; pub mod traits; pub use error:: {ProcessingError, Result}; pub use config:: CompressionConfig; pub use rust_singler:: RustSingler; use rust_singler:: cli:: CliApplication; use std:: process; fn main(){let app = CliApplication:: new(); let args = CliApplication:: parse_arguments(); if let Err(e) = app.run(args){eprintln!("❌ Error: {}", e); process:: exit(1);}} use crate :: error:: Result; use crate :: syntax_tree:: SyntaxTree; use crate :: traits:: CodeMinifier; use proc_macro2:: {Spacing, TokenStream, TokenTree}; pub struct WhitespaceMinifier{preserve_string_literals: bool,}impl WhitespaceMinifier{pub fn new() -> Self{Self{preserve_string_literals: true,}}pub fn with_string_preservation(mut self, preserve: bool) -> Self{self.preserve_string_literals = preserve; self}}impl CodeMinifier for WhitespaceMinifier{fn minify(& self, tree:& SyntaxTree) -> Result < String > {let tokens = tree.to_token_stream(); self.compress_token_stream(& tokens)}fn compress_to_single_line(& self, code:& str) -> Result < String > {let tokens: TokenStream = code.parse().map_err(| e | {crate :: error:: ProcessingError:: IoError(std:: io:: Error:: new(std:: io:: ErrorKind:: InvalidData, format!("Failed to parse Rust code: {}", e)))})?; self.compress_token_stream(& tokens)}}impl Default for WhitespaceMinifier{fn default() -> Self{Self:: new()}}impl WhitespaceMinifier{#}#[derive(Debug, Clone, Copy, PartialEq)]enum TokenType{None, Group, Ident, Literal, OpenDelim, CloseDelim, Separator, Colon, DoubleColon, Bang, Operator, Dot, Punct,} use syn:: {parse_file, Attribute, Item, ItemFn, ItemMod, Meta, AttrStyle, visit_mut:: {self, VisitMut}}; use crate :: error:: {ProcessingError, Result}; use crate :: syntax_tree:: SyntaxTree; use crate :: traits:: CodeParser; pub struct SynCodeParser; impl SynCodeParser{pub fn new() -> Self{Self}#}impl CodeParser for SynCodeParser{fn parse(& self, content:& str) -> Result < SyntaxTree > {let file = parse_file(content).map_err(| e | ProcessingError:: ParseError(e.to_string()))?; Ok(SyntaxTree:: new(file))}fn remove_unwanted_elements(& self, tree:& mut SyntaxTree) -> Result < () > {self.remove_test_code(tree); self.remove_comments(tree); self.remove_cfg_test_attributes(tree); Ok(())}}impl Default for SynCodeParser{fn default() -> Self{Self:: new()}}struct CommentRemover; impl VisitMut for CommentRemover{fn visit_file_mut(& mut self, file:& mut syn:: File){file.attrs.retain(| attr |!self.is_doc_attribute(attr)); visit_mut:: visit_file_mut(self, file);}fn visit_item_mut(& mut self, item:& mut Item){match item{Item:: Fn(func) => {func.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Struct(s) => {s.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Enum(e) => {e.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Mod(m) => {m.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Use(u) => {u.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Type(t) => {t.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Const(c) => {c.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Static(s) => {s.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Trait(t) => {t.attrs.retain(| attr |!self.is_doc_attribute(attr));}Item:: Impl(i) => {i.attrs.retain(| attr |!self.is_doc_attribute(attr));}_ => {}}visit_mut:: visit_item_mut(self, item);}fn visit_field_mut(& mut self, field:& mut syn:: Field){field.attrs.retain(| attr |!self.is_doc_attribute(attr)); visit_mut:: visit_field_mut(self, field);}fn visit_variant_mut(& mut self, variant:& mut syn:: Variant){variant.attrs.retain(| attr |!self.is_doc_attribute(attr)); visit_mut:: visit_variant_mut(self, variant);}}impl CommentRemover{#}struct TestCodeRemover; impl VisitMut for TestCodeRemover{fn visit_item_mod_mut(& mut self, module:& mut ItemMod){if let Some((_, items)) =& mut module.content{items.retain(| item | {match item{Item:: Fn(func) =>!func.attrs.iter().any(| attr | {if let Meta:: Path(path) =& attr.meta{path.is_ident("test") || path.is_ident("bench")}else {false}}), _ => true,}});}visit_mut:: visit_item_mod_mut(self, module);}}struct CfgTestRemover; impl VisitMut for CfgTestRemover{fn visit_item_mut(& mut self, item:& mut Item){match item{Item:: Fn(func) => {func.attrs.retain(| attr |!is_cfg_test_attr(attr));}Item:: Mod(m) => {m.attrs.retain(| attr |!is_cfg_test_attr(attr));}Item:: Struct(s) => {s.attrs.retain(| attr |!is_cfg_test_attr(attr));}Item:: Enum(e) => {e.attrs.retain(| attr |!is_cfg_test_attr(attr));}_ => {}}visit_mut:: visit_item_mut(self, item);}}fn is_cfg_test_attr(attr:& Attribute) -> bool{if let Meta:: List(list) =& attr.meta{if list.path.is_ident("cfg"){return list.tokens.to_string().contains("test");}}false} use std:: collections:: HashMap; use std:: time:: {Duration, Instant}; use crate :: traits:: PerformanceTracker; pub struct MetricsCollector{timers: HashMap < String, Instant >, metrics: HashMap < String, Duration >, enabled: bool,}impl MetricsCollector{pub fn new() -> Self{Self{timers: HashMap:: new(), metrics: HashMap:: new(), enabled: true,}}pub fn with_enabled(mut self, enabled: bool) -> Self{self.enabled = enabled; self}#}impl PerformanceTracker for MetricsCollector{fn start_timer(& mut self, operation:& str){if self.enabled{self.timers.insert(operation.to_string(), Instant:: now());}}fn end_timer(& mut self, operation:& str){if!self.enabled{return;}if let Some(start_time) = self.timers.remove(operation){let duration = start_time.elapsed(); self.metrics.insert(operation.to_string(), duration);}}fn report_metrics(& self){if!self.enabled || self.metrics.is_empty(){return;}println!("\n📊 Performance Metrics:"); println!("{}", "─".repeat(50)); let mut operations: Vec < _ >= self.metrics.iter().collect(); operations.sort_by_key(| (_, duration) |* duration); operations.reverse(); for(operation, duration)in operations{println!("  {:<30} {:>8.2}ms", operation, duration.as_secs_f64() * 1000.0);}let total = self.get_total_processing_time(); println!("{}", "─".repeat(50)); println!("  {:<30} {:>8.2}ms", "Total", total.as_secs_f64() * 1000.0);}}impl Default for MetricsCollector{fn default() -> Self{Self:: new()}}pub struct NoOpPerformanceTracker; impl PerformanceTracker for NoOpPerformanceTracker{fn start_timer(& mut self, _operation:& str){}fn end_timer(& mut self, _operation:& str){}fn report_metrics(& self){}} use colored:: Colorize; use crate :: error:: ProcessingError; use crate :: traits:: ErrorReporter; pub struct ConsoleErrorReporter{use_colors: bool,}impl ConsoleErrorReporter{pub fn new() -> Self{Self{use_colors: true,}}pub fn with_colors(mut self, use_colors: bool) -> Self{self.use_colors = use_colors; self}#}impl ErrorReporter for ConsoleErrorReporter{fn report_error(& self, error:& ProcessingError){let message = self.format_error_message(error); eprintln!("{}", message);}fn format_error_message(& self, error:& ProcessingError) -> String{match error{ProcessingError:: FileNotFound(path) => {format!("{}: File not found: {}", self.format_with_colors("Error", ColorType:: Error), self.format_with_colors(& path.display().to_string(), ColorType:: Path))}ProcessingError:: ParseError(msg) => {format!("{}: Failed to parse Rust code: {}", self.format_with_colors("Parse Error", ColorType:: Error), msg)}ProcessingError:: IoError(io_err) => {format!("{}: I/O operation failed: {}", self.format_with_colors("I/O Error", ColorType:: Error), io_err)}ProcessingError:: CompressionError(msg) => {format!("{}: Code compression failed: {}", self.format_with_colors("Compression Error", ColorType:: Error), msg)}ProcessingError:: InvalidPath(path) => {format!("{}: Invalid path specified: {}", self.format_with_colors("Invalid Path", ColorType:: Error), self.format_with_colors(& path.display().to_string(), ColorType:: Path))}ProcessingError:: OutputDirectoryError(msg) => {format!("{}: Failed to create output directory: {}", self.format_with_colors("Directory Error", ColorType:: Error), msg)}}}}impl Default for ConsoleErrorReporter{fn default() -> Self{Self:: new()}}#[derive(Debug, Clone, Copy)]#[allow(dead_code)]enum ColorType{Error, Warning, Info, Success, Path,}pub struct SilentErrorReporter; impl ErrorReporter for SilentErrorReporter{fn report_error(& self, _error:& ProcessingError){}fn format_error_message(& self, error:& ProcessingError) -> String{error.to_string()}} use std:: path:: Path; use crate :: config:: CompressionConfig; use crate :: error:: {ProcessingError, Result}; use crate :: traits:: {FileDiscovery, CodeParser, CodeMinifier, FileProcessor, ErrorReporter, PerformanceTracker}; pub struct RustSingler{file_discovery: Box < dyn FileDiscovery >, code_parser: Box < dyn CodeParser >, code_minifier: Box < dyn CodeMinifier >, file_processor: Box < dyn FileProcessor >, error_reporter: Box < dyn ErrorReporter >, performance_tracker: Box < dyn PerformanceTracker >, config: CompressionConfig,}impl RustSingler{#} use syn:: {File, Item}; use proc_macro2:: TokenStream; use quote:: ToTokens; #[derive(Debug, Clone)]pub struct SyntaxTree{file: File,}impl SyntaxTree{#}impl From < File > for SyntaxTree{fn from(file: File) -> Self{Self:: new(file)}}impl Into < File > for SyntaxTree{fn into(self) -> File{self.file}} use std:: path:: {Path, PathBuf}; use crate :: error:: Result; use crate :: syntax_tree:: SyntaxTree; pub trait FileDiscovery{#}pub trait CodeParser{#}pub trait CodeMinifier{#}pub trait FileProcessor{#}pub trait ErrorReporter{#}pub trait PerformanceTracker{#}